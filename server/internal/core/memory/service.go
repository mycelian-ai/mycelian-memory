package memory

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"regexp"
	"strings"

	"github.com/google/uuid"
	"github.com/rs/zerolog/log"

	"github.com/mycelian/mycelian-memory/server/internal/storage"
)

// Service contains the core business logic for memory operations
type Service struct {
	storage storage.Storage
}

// NewService creates a new memory service
func NewService(storage storage.Storage) *Service {
	return &Service{
		storage: storage,
	}
}

// CreateUser creates a new user with business validation
func (s *Service) CreateUser(ctx context.Context, req CreateUserRequest) (*storage.User, error) {
	// Validate payload
	if err := s.validateCreateUserRequest(req); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Default timezone
	if req.TimeZone == "" {
		req.TimeZone = "UTC"
	}

	// Pass through to storage with caller-supplied userId as primary key
	createReq := storage.CreateUserRequest{
		UserID:      req.UserID,
		Email:       req.Email,
		DisplayName: req.DisplayName,
		TimeZone:    req.TimeZone,
	}

	log.Info().Str("userId", req.UserID).Msg("Creating user")

	user, err := s.storage.CreateUser(ctx, createReq)
	if err != nil {
		// Detect duplicate user (unique/primary key violation) by inspecting error string.
		// Storage drivers should bubble up a recognizable message.
		if strings.Contains(strings.ToLower(err.Error()), "unique") || strings.Contains(err.Error(), "ALREADY_EXISTS") {
			return nil, NewConflictError("userId", "already exists")
		}
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	return user, nil
}

// GetUser retrieves a user by ID
func (s *Service) GetUser(ctx context.Context, userID string) (*storage.User, error) {
	if userID == "" {
		return nil, fmt.Errorf("user ID is required")
	}

	user, err := s.storage.GetUser(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user: %w", err)
	}

	return user, nil
}

// CreateMemory creates a new memory with business validation
func (s *Service) CreateMemory(ctx context.Context, req CreateMemoryRequest) (*storage.Memory, error) {
	// Business validation
	if err := s.validateCreateMemoryRequest(req); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Create storage request (MemoryID will be generated by the Store)
	createReq := storage.CreateMemoryRequest{
		VaultID:     req.VaultID,
		UserID:      req.UserID,
		MemoryType:  req.MemoryType,
		Title:       req.Title,
		Description: req.Description,
	}

	log.Info().Str("userID", req.UserID).Msg("Creating memory")

	memory, err := s.storage.CreateMemory(ctx, createReq)
	if err != nil {
		return nil, fmt.Errorf("failed to create memory: %w", err)
	}

	return memory, nil
}

// GetMemory retrieves a memory by user ID and memory ID
func (s *Service) GetMemory(ctx context.Context, userID string, vaultID uuid.UUID, memoryID string) (*storage.Memory, error) {
	if userID == "" || memoryID == "" || vaultID == uuid.Nil {
		return nil, fmt.Errorf("user ID, vault ID and memory ID are required")
	}

	memory, err := s.storage.GetMemory(ctx, userID, vaultID, memoryID)
	if err != nil {
		return nil, fmt.Errorf("failed to get memory: %w", err)
	}

	return memory, nil
}

// GetMemoryByTitle retrieves a memory by title within vault.
func (s *Service) GetMemoryByTitle(ctx context.Context, userID string, vaultID uuid.UUID, title string) (*storage.Memory, error) {
	if userID == "" || title == "" || vaultID == uuid.Nil {
		return nil, fmt.Errorf("userID, vaultID, and title are required")
	}
	return s.storage.GetMemoryByTitle(ctx, userID, vaultID, title)
}

// ListMemories retrieves all memories for a user
func (s *Service) ListMemories(ctx context.Context, userID string, vaultID uuid.UUID) ([]*storage.Memory, error) {
	if userID == "" || vaultID == uuid.Nil {
		return nil, fmt.Errorf("user ID and vault ID are required")
	}

	memories, err := s.storage.ListMemories(ctx, userID, vaultID)
	if err != nil {
		return nil, fmt.Errorf("failed to list memories: %w", err)
	}

	return memories, nil
}

// DeleteMemory deletes a memory
func (s *Service) DeleteMemory(ctx context.Context, userID string, vaultID uuid.UUID, memoryID string) error {
	if userID == "" || memoryID == "" || vaultID == uuid.Nil {
		return fmt.Errorf("user ID, vault ID and memory ID are required")
	}

	log.Info().Str("userID", userID).Str("vaultID", vaultID.String()).Str("memoryID", memoryID).Msg("Deleting memory")

	err := s.storage.DeleteMemory(ctx, userID, vaultID, memoryID)
	if err != nil {
		return fmt.Errorf("failed to delete memory: %w", err)
	}

	return nil
}

// CreateMemoryEntry creates a new memory entry with business validation
func (s *Service) CreateMemoryEntry(ctx context.Context, req CreateMemoryEntryRequest) (*storage.MemoryEntry, error) {
	// Business validation
	if err := s.validateCreateMemoryEntryRequest(req); err != nil {
		return nil, fmt.Errorf("validation failed: %w", err)
	}

	// Create storage request (EntryID will be generated by the Store)
	createReq := storage.CreateMemoryEntryRequest{
		VaultID:        req.VaultID,
		UserID:         req.UserID,
		MemoryID:       req.MemoryID,
		RawEntry:       req.RawEntry,
		Summary:        req.Summary,
		Metadata:       req.Metadata,
		Tags:           req.Tags,
		ExpirationTime: req.ExpirationTime,
	}

	log.Info().Str("userID", req.UserID).Str("vaultID", req.VaultID.String()).Str("memoryID", req.MemoryID).Msg("Creating memory entry")

	entry, err := s.storage.CreateMemoryEntry(ctx, createReq)
	if err != nil {
		return nil, fmt.Errorf("failed to create memory entry: %w", err)
	}

	// Emit detailed post-persist log including entryID and active storage driver for easier debugging
	dbDriver := os.Getenv("MEMORY_SERVER_DB_DRIVER")
	if dbDriver == "" {
		dbDriver = "unknown"
	}
	log.Info().
		Str("userID", req.UserID).
		Str("vaultID", req.VaultID.String()).
		Str("memoryID", req.MemoryID).
		Str("entryID", entry.EntryID).
		Str("db_driver", dbDriver).
		Msg("memory entry persisted")

	return entry, nil
}

// ListMemoryEntries retrieves memory entries with filtering
func (s *Service) ListMemoryEntries(ctx context.Context, req ListMemoryEntriesRequest) ([]*storage.MemoryEntry, error) {
	if req.UserID == "" || req.MemoryID == "" || req.VaultID == uuid.Nil {
		return nil, fmt.Errorf("user ID, vault ID and memory ID are required")
	}

	// Apply business rules for limits
	if req.Limit <= 0 {
		req.Limit = 50 // Default limit
	}
	if req.Limit > 1000 {
		req.Limit = 1000 // Maximum limit
	}

	// Create storage request
	storageReq := storage.ListMemoryEntriesRequest{
		UserID:   req.UserID,
		VaultID:  req.VaultID,
		MemoryID: req.MemoryID,
		Limit:    req.Limit,
		Before:   req.Before,
		After:    req.After,
	}

	entries, err := s.storage.ListMemoryEntries(ctx, storageReq)
	if err != nil {
		return nil, fmt.Errorf("failed to list memory entries: %w", err)
	}

	return entries, nil
}

// GetMemoryEntryByID fetches a single entry by entryId
func (s *Service) GetMemoryEntryByID(ctx context.Context, userID string, vaultID uuid.UUID, memoryID string, entryID string) (*storage.MemoryEntry, error) {
	if userID == "" || memoryID == "" || entryID == "" || vaultID == uuid.Nil {
		return nil, fmt.Errorf("user ID, vault ID, memory ID and entry ID are required")
	}
	entry, err := s.storage.GetMemoryEntryByID(ctx, userID, vaultID, memoryID, entryID)
	if err != nil {
		return nil, fmt.Errorf("failed to get memory entry by id: %w", err)
	}
	return entry, nil
}

// DeleteMemoryEntryByID deletes a single entry by entryId (hard delete)
func (s *Service) DeleteMemoryEntryByID(ctx context.Context, userID string, vaultID uuid.UUID, memoryID, entryID string) error {
	if userID == "" || memoryID == "" || entryID == "" || vaultID == uuid.Nil {
		return fmt.Errorf("user ID, vault ID, memory ID and entry ID are required")
	}
	return s.storage.DeleteMemoryEntryByID(ctx, userID, vaultID, memoryID, entryID)
}

// DeleteMemoryContextByID deletes a context snapshot by contextId (hard delete)
func (s *Service) DeleteMemoryContextByID(ctx context.Context, userID string, vaultID uuid.UUID, memoryID, contextID string) error {
	if userID == "" || memoryID == "" || contextID == "" || vaultID == uuid.Nil {
		return fmt.Errorf("user ID, vault ID, memory ID and context ID are required")
	}
	return s.storage.DeleteMemoryContextByID(ctx, userID, vaultID, memoryID, contextID)
}

// UpdateMemoryEntryTags updates the tags of a memory entry
func (s *Service) UpdateMemoryEntryTags(ctx context.Context, req UpdateMemoryEntryTagsRequest) (*storage.MemoryEntry, error) {
	// Business validation
	if req.UserID == "" || req.MemoryID == "" || req.VaultID == uuid.Nil {
		return nil, fmt.Errorf("user ID, vault ID and memory ID are required")
	}

	// Create storage request
	updateReq := storage.UpdateMemoryEntryTagsRequest{
		VaultID:  req.VaultID,
		UserID:   req.UserID,
		MemoryID: req.MemoryID,
		EntryID:  req.EntryID,
		Tags:     req.Tags,
	}

	log.Info().Str("userID", req.UserID).Str("memoryID", req.MemoryID).Str("entryId", req.EntryID).Msg("Updating memory entry tags")

	entry, err := s.storage.UpdateMemoryEntryTags(ctx, updateReq)
	if err != nil {
		// Convert storage errors to domain validation errors
		if strings.Contains(err.Error(), "ENTRY_NOT_FOUND") {
			return nil, NewValidationError("entry", "memory entry not found")
		}
		if strings.Contains(err.Error(), "IMMUTABILITY_VIOLATION") {
			return nil, NewValidationError("entry", "cannot update tags of corrected or deleted entry")
		}
		return nil, fmt.Errorf("failed to update memory entry tags: %w", err)
	}

	return entry, nil
}

// CreateMemoryContext creates a new context snapshot for a memory
func (s *Service) CreateMemoryContext(ctx context.Context, req CreateMemoryContextRequest) (*storage.MemoryContext, error) {
	// Basic validation
	if req.UserID == "" || req.MemoryID == "" {
		return nil, fmt.Errorf("user ID and memory ID are required")
	}
	trimmed := strings.TrimSpace(string(req.Context))
	if trimmed == "" {
		return nil, NewValidationError("context", "payload must not be empty")
	}

	// Deep invariant: ensure JSON object with non-empty string fragments
	var fragments map[string]interface{}
	if err := json.Unmarshal(req.Context, &fragments); err != nil {
		return nil, NewValidationError("context", "must be a JSON object")
	}
	for k, v := range fragments {
		str, ok := v.(string)
		if !ok {
			return nil, NewValidationError(k, "fragment must be a string")
		}
		if strings.TrimSpace(str) == "" {
			log.Warn().Str("fragment", k).Msg("empty context fragment rejected")
			return nil, NewValidationError(k, "fragment must not be empty")
		}
	}

	storageReq := storage.CreateMemoryContextRequest{
		UserID:    req.UserID,
		VaultID:   req.VaultID,
		MemoryID:  req.MemoryID,
		ContextID: req.ContextID,
		Context:   req.Context,
	}

	ctxObj, err := s.storage.CreateMemoryContext(ctx, storageReq)
	if err != nil {
		return nil, fmt.Errorf("failed to create memory context: %w", err)
	}

	// Debug log for context snapshot creation
	dbDriver := os.Getenv("MEMORY_SERVER_DB_DRIVER")
	if dbDriver == "" {
		dbDriver = "unknown"
	}
	log.Info().
		Str("userID", req.UserID).
		Str("vaultID", req.VaultID.String()).
		Str("memoryID", req.MemoryID).
		Str("contextID", ctxObj.ContextID).
		Str("db_driver", dbDriver).
		Msg("memory context snapshot persisted")

	return ctxObj, nil
}

// GetLatestMemoryContext fetches the most recent context snapshot for a memory.
// A thin pass-through to the storage layer with basic argument validation.
func (s *Service) GetLatestMemoryContext(ctx context.Context, userID string, vaultID uuid.UUID, memoryID string) (*storage.MemoryContext, error) {
	if userID == "" || memoryID == "" || vaultID == uuid.Nil {
		return nil, fmt.Errorf("user ID, vault ID and memory ID are required")
	}

	ctxObj, err := s.storage.GetLatestMemoryContext(ctx, userID, vaultID, memoryID)
	if err != nil {
		return nil, fmt.Errorf("failed to get latest memory context: %w", err)
	}
	return ctxObj, nil
}

// Validation methods
func (s *Service) validateCreateUserRequest(req CreateUserRequest) error {
	if req.UserID == "" {
		return NewValidationError("userId", "userId is required")
	}
	if !validateUserID(req.UserID) {
		return NewValidationError("userId", "must be lowercase letters, numbers or underscore (1-20 chars)")
	}
	if req.Email == "" {
		return NewValidationError("email", "email is required")
	}
	return nil
}

func (s *Service) validateCreateMemoryRequest(req CreateMemoryRequest) error {
	if req.VaultID == uuid.Nil {
		return NewValidationError("vaultID", "vault ID is required")
	}
	if req.UserID == "" {
		return NewValidationError("userID", "user ID is required")
	}
	if req.MemoryType == "" {
		return NewValidationError("memoryType", "memory type is required")
	}
	if req.Title == "" {
		return NewValidationError("title", "title is required")
	}
	if len(req.Title) > 50 {
		return NewValidationError("title", "title exceeds 50 characters")
	}
	if !titleRx.MatchString(req.Title) {
		return NewValidationError("title", "title contains invalid characters; allowed letters, digits, hyphen")
	}
	if req.Description != nil && len(*req.Description) > 500 {
		return NewValidationError("description", "description exceeds 500 characters")
	}
	// Add more validation as needed
	return nil
}

func (s *Service) validateCreateMemoryEntryRequest(req CreateMemoryEntryRequest) error {
	if req.VaultID == uuid.Nil {
		return NewValidationError("vaultID", "vault ID is required")
	}
	if req.UserID == "" {
		return NewValidationError("userID", "user ID is required")
	}
	if req.MemoryID == "" {
		return NewValidationError("memoryID", "memory ID is required")
	}
	if len(req.RawEntry) == 0 {
		return NewValidationError("rawEntry", "raw entry is required")
	}
	return nil
}

// title validation regex shared by memory & vault services
var titleRx = regexp.MustCompile(`^[A-Za-z0-9\-]+$`)

// validateUserID uses same pattern as api/validate but avoids import cycle
func validateUserID(u string) bool {
	if len(u) == 0 || len(u) > 20 {
		return false
	}
	for _, r := range u {
		if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '_' {
			return false
		}
	}
	return true
}
