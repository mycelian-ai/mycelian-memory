//go:build legacy
// +build legacy

package storage

import (
	"context"
	"fmt"
	"os"
	"testing"

	"cloud.google.com/go/spanner"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"google.golang.org/api/option"
)

// TestRealSpannerIntegration tests against actual Google Cloud Spanner
// Run with: REAL_SPANNER=true go test -v -run TestRealSpannerIntegration
func TestRealSpannerIntegration(t *testing.T) {
	if os.Getenv("REAL_SPANNER") != "true" {
		t.Skip("Skipping real Spanner integration tests. Set REAL_SPANNER=true to run.")
	}

	ctx := context.Background()

	// Real Spanner configuration
	projectID := getEnvOrDefault("GCP_PROJECT_ID", "artful-guru-459003-k4")
	instanceID := getEnvOrDefault("SPANNER_INSTANCE_ID", "test")
	databaseID := getEnvOrDefault("SPANNER_DATABASE_ID", "memories")
	credentialsPath := os.Getenv("GOOGLE_APPLICATION_CREDENTIALS")

	t.Logf("ðŸŽ¯ Phase 6.2: Real Spanner Integration Tests")
	t.Logf("Project: %s, Instance: %s, Database: %s", projectID, instanceID, databaseID)

	// Temporarily unset emulator host for this test (TestMain sets it for other tests)
	originalEmulatorHost := os.Getenv("SPANNER_EMULATOR_HOST")
	os.Unsetenv("SPANNER_EMULATOR_HOST")
	defer func() {
		if originalEmulatorHost != "" {
			os.Setenv("SPANNER_EMULATOR_HOST", originalEmulatorHost)
		}
	}()

	// Verify credentials are configured
	if credentialsPath != "" {
		require.FileExists(t, credentialsPath, "Google Cloud credentials file must exist")
		t.Logf("Using credentials: %s", credentialsPath)
	} else {
		t.Log("Using Application Default Credentials (ADC)")
	}

	// Create real Spanner client
	databasePath := fmt.Sprintf("projects/%s/instances/%s/databases/%s", projectID, instanceID, databaseID)

	var clientOptions []option.ClientOption
	if credentialsPath != "" {
		clientOptions = append(clientOptions, option.WithCredentialsFile(credentialsPath))
	}

	client, err := spanner.NewClient(ctx, databasePath, clientOptions...)
	require.NoError(t, err, "Failed to create real Spanner client")
	defer client.Close()

	t.Log("âœ… Successfully connected to real Spanner")

	// Create storage instance for testing
	storage := NewSpannerStorage(client)

	// Run comprehensive UUID generation tests
	t.Run("UUIDGeneration", func(t *testing.T) {
		testUUIDGeneration(t, ctx, storage)
	})

	t.Run("UserOperations", func(t *testing.T) {
		testUserOperations(t, ctx, storage)
	})

	t.Run("MemoryOperations", func(t *testing.T) {
		testMemoryOperations(t, ctx, storage)
	})

	t.Run("MemoryEntryOperations", func(t *testing.T) {
		testMemoryEntryOperations(t, ctx, storage)
	})

	t.Run("ConcurrentUUIDGeneration", func(t *testing.T) {
		testConcurrentUUIDGeneration(t, ctx, storage)
	})
}

// testUUIDGeneration validates that client-generated UUIDs work correctly for all entities
func testUUIDGeneration(t *testing.T, ctx context.Context, storage Storage) {
	t.Log("ðŸ§ª Testing Spanner UUID generation...")

	// Test User UUID generation
	displayName := "UUID Test User"
	user, err := storage.CreateUser(ctx, CreateUserRequest{
		Email:       "test-uuid-user@example.com",
		DisplayName: &displayName,
		TimeZone:    "UTC",
	})
	require.NoError(t, err, "Failed to create user")
	assert.NotEmpty(t, user.UserID, "User UUID should be generated by Spanner")
	assert.Len(t, user.UserID, 36, "User UUID should be 36 characters (UUID4 format)")
	t.Logf("âœ… User UUID generated: %s", user.UserID)

	// Test Memory UUID generation
	description := "Testing UUID generation"
	memory, err := storage.CreateMemory(ctx, CreateMemoryRequest{
		UserID:      user.UserID,
		MemoryType:  "CONVERSATION",
		Title:       "UUID Test Memory",
		Description: &description,
	})
	require.NoError(t, err, "Failed to create memory")
	assert.NotEmpty(t, memory.MemoryID, "Memory UUID should be generated by Spanner")
	assert.Len(t, memory.MemoryID, 36, "Memory UUID should be 36 characters (UUID4 format)")
	t.Logf("âœ… Memory UUID generated: %s", memory.MemoryID)

	// Test MemoryEntry UUID generation
	summary := "Test summary"
	entry, err := storage.CreateMemoryEntry(ctx, CreateMemoryEntryRequest{
		UserID:   user.UserID,
		MemoryID: memory.MemoryID,
		RawEntry: "UUID test entry content",
		Summary:  &summary,
	})
	require.NoError(t, err, "Failed to create memory entry")
	assert.NotEmpty(t, entry.EntryID, "MemoryEntry UUID should be generated by Spanner")
	assert.Len(t, entry.EntryID, 36, "MemoryEntry UUID should be 36 characters (UUID4 format)")
	t.Logf("âœ… MemoryEntry UUID generated: %s", entry.EntryID)

	// Verify all UUIDs are unique
	assert.NotEqual(t, user.UserID, memory.MemoryID, "User and Memory UUIDs should be different")
	assert.NotEqual(t, user.UserID, entry.EntryID, "User and MemoryEntry UUIDs should be different")
	assert.NotEqual(t, memory.MemoryID, entry.EntryID, "Memory and MemoryEntry UUIDs should be different")

	t.Log("âœ… All UUID generation tests passed")
}

// testUserOperations validates basic user CRUD operations with real Spanner
func testUserOperations(t *testing.T, ctx context.Context, storage Storage) {
	t.Log("ðŸ§ª Testing user operations with real Spanner...")

	// Create user
	displayName := "Real Spanner User"
	user, err := storage.CreateUser(ctx, CreateUserRequest{
		Email:       "real-spanner-user@example.com",
		DisplayName: &displayName,
		TimeZone:    "UTC",
	})
	require.NoError(t, err, "Failed to create user")
	t.Logf("âœ… Created user: %s", user.UserID)

	// Get user
	retrievedUser, err := storage.GetUser(ctx, user.UserID)
	require.NoError(t, err, "Failed to get user")
	assert.Equal(t, user.UserID, retrievedUser.UserID, "Retrieved user ID should match")
	assert.Equal(t, user.Email, retrievedUser.Email, "Retrieved user email should match")
	t.Log("âœ… User retrieval successful")

	// Test health check
	err = storage.HealthCheck(ctx)
	require.NoError(t, err, "Health check should pass")
	t.Log("âœ… Health check passed")
}

// testMemoryOperations validates memory operations with real Spanner
func testMemoryOperations(t *testing.T, ctx context.Context, storage Storage) {
	t.Log("ðŸ§ª Testing memory operations with real Spanner...")

	// Create user first
	displayName := "Memory Test User"
	user, err := storage.CreateUser(ctx, CreateUserRequest{
		Email:       "memory-test-user@example.com",
		DisplayName: &displayName,
		TimeZone:    "UTC",
	})
	require.NoError(t, err, "Failed to create user for memory tests")

	// Create memory
	description := "Testing memory operations"
	memory, err := storage.CreateMemory(ctx, CreateMemoryRequest{
		UserID:      user.UserID,
		MemoryType:  "PROJECT",
		Title:       "Real Spanner Memory",
		Description: &description,
	})
	require.NoError(t, err, "Failed to create memory")
	t.Logf("âœ… Created memory: %s", memory.MemoryID)

	// Get memory
	retrievedMemory, err := storage.GetMemory(ctx, user.UserID, memory.MemoryID)
	require.NoError(t, err, "Failed to get memory")
	assert.Equal(t, memory.MemoryID, retrievedMemory.MemoryID, "Retrieved memory ID should match")
	assert.Equal(t, memory.Title, retrievedMemory.Title, "Retrieved memory title should match")
	t.Log("âœ… Memory retrieval successful")

	// List memories
	memories, err := storage.ListMemories(ctx, user.UserID)
	require.NoError(t, err, "Failed to list memories")
	assert.GreaterOrEqual(t, len(memories), 1, "Should have at least one memory")
	t.Logf("âœ… Listed %d memories", len(memories))
}

// testMemoryEntryOperations validates memory entry operations with real Spanner
func testMemoryEntryOperations(t *testing.T, ctx context.Context, storage Storage) {
	t.Log("ðŸ§ª Testing memory entry operations with real Spanner...")

	// Create user and memory first
	displayName := "Entry Test User"
	user, err := storage.CreateUser(ctx, CreateUserRequest{
		Email:       "entry-test-user@example.com",
		DisplayName: &displayName,
		TimeZone:    "UTC",
	})
	require.NoError(t, err, "Failed to create user for entry tests")

	description := "Testing entry operations"
	memory, err := storage.CreateMemory(ctx, CreateMemoryRequest{
		UserID:      user.UserID,
		MemoryType:  "CONVERSATION",
		Title:       "Entry Test Memory",
		Description: &description,
	})
	require.NoError(t, err, "Failed to create memory for entry tests")

	// Create memory entry
	summary := "Entry summary"
	entry, err := storage.CreateMemoryEntry(ctx, CreateMemoryEntryRequest{
		UserID:   user.UserID,
		MemoryID: memory.MemoryID,
		RawEntry: "Real Spanner entry content",
		Summary:  &summary,
	})
	require.NoError(t, err, "Failed to create memory entry")
	t.Logf("âœ… Created memory entry: %s", entry.EntryID)

	// Get memory entry
	retrievedEntry, err := storage.GetMemoryEntry(ctx, user.UserID, memory.MemoryID, entry.CreationTime)
	require.NoError(t, err, "Failed to get memory entry")
	assert.Equal(t, entry.EntryID, retrievedEntry.EntryID, "Retrieved entry ID should match")
	assert.Equal(t, entry.RawEntry, retrievedEntry.RawEntry, "Retrieved entry content should match")
	t.Log("âœ… Memory entry retrieval successful")

	// List memory entries
	entries, err := storage.ListMemoryEntries(ctx, ListMemoryEntriesRequest{
		UserID:   user.UserID,
		MemoryID: memory.MemoryID,
		Limit:    10,
	})
	require.NoError(t, err, "Failed to list memory entries")
	assert.GreaterOrEqual(t, len(entries), 1, "Should have at least one memory entry")
	t.Logf("âœ… Listed %d memory entries", len(entries))
}

// testConcurrentUUIDGeneration tests that concurrent operations generate unique UUIDs
func testConcurrentUUIDGeneration(t *testing.T, ctx context.Context, storage Storage) {
	t.Log("ðŸ§ª Testing concurrent UUID generation...")

	const numConcurrent = 10
	userIds := make(chan string, numConcurrent)
	errChan := make(chan error, numConcurrent)

	// Create multiple users concurrently
	for i := 0; i < numConcurrent; i++ {
		go func(i int) {
			displayName := fmt.Sprintf("Concurrent User %d", i)
			user, err := storage.CreateUser(ctx, CreateUserRequest{
				Email:       fmt.Sprintf("concurrent-user-%d@example.com", i),
				DisplayName: &displayName,
				TimeZone:    "UTC",
			})
			if err != nil {
				errChan <- err
				return
			}
			userIds <- user.UserID
		}(i)
	}

	// Collect results
	var collectedUserIds []string
	for i := 0; i < numConcurrent; i++ {
		select {
		case userId := <-userIds:
			collectedUserIds = append(collectedUserIds, userId)
		case err := <-errChan:
			t.Fatalf("Concurrent user creation failed: %v", err)
		}
	}

	// Verify all UUIDs are unique
	require.Len(t, collectedUserIds, numConcurrent, "Should have created all users")

	uniqueIds := make(map[string]bool)
	for _, id := range collectedUserIds {
		assert.False(t, uniqueIds[id], "UUID %s should be unique", id)
		uniqueIds[id] = true
		assert.Len(t, id, 36, "UUID should be 36 characters")
	}

	t.Logf("âœ… All %d concurrent UUIDs are unique", numConcurrent)
}

// getEnvOrDefault returns environment variable value or default if not set
func getEnvOrDefault(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}
