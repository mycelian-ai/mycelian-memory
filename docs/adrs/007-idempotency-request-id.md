# ADR-007: Idempotency & Request-ID Semantics

**Status**: Accepted  
**Date**: 2025-07-27

## Context

Reliable client retries require two related but distinct tokens:

1. **Idempotency-Key** – identifies a *logical* state-changing operation for server deduplication
2. **Request-Id** – identifies a *single HTTP attempt* for tracing and log correlation

Industry practice (AWS ClientToken, Stripe Idempotency-Key, Google `request_id`) follows this split.

## Decision

### Header Names
- REST: `Idempotency-Key`, `Request-Id` headers
- MCP tools: optional arguments `idempotency_key`, `request_id`
- CLI flags: `--idempotency-key`, `--request-id`

### SDK Behaviour

#### Generation Responsibilities
**Idempotency-Key**
- **Preferred source**: Caller (AI agent, client application) passes stable key when logical write should be idempotent across retries
- **SDK fallback**: When caller omits header, Go SDK generates UUID-v4 once per logical operation and reuses on automatic retries
- Guarantees safety for naive clients while encouraging advanced callers to provide own key

**Request-Id**  
- Always generated by **Go SDK** for *every* HTTP attempt (each retry) unless caller explicitly overrides
- **Never** reused across retries—even when Idempotency-Key is reused
- Echoed in server responses and logs for trace correlation

### Server Behaviour
- Maintain `<method, canonical_path, Idempotency-Key>` key for 24h
- If duplicate arrives with same body → return stored 2xx/4xx result
- If duplicate body differs → return `409 Conflict` with error `idempotency_mismatch`
- Always echo both headers (`Idempotency-Key`, `Request-Id`)

### TTL & Storage
- Keys live for 24h (configurable); cleanup via background sweep
- Implementation: Database table with composite primary key

## Consequences

### Positive Consequences
- **Safety**: SDK-managed keys provide automatic at-most-once semantics
- **Observability**: Request-Id enables end-to-end trace correlation  
- **Flexibility**: Advanced clients can override both headers for custom workflows

### Negative Consequences
- Additional storage overhead for tracking idempotency keys
- Complexity in handling edge cases (body mismatches, expired keys)

## Alternatives Considered

### Alternative 1: Single Combined Token
**Why rejected**: Blurs deduplication vs. tracing concerns; breaks attempt-level visibility

### Alternative 2: Force Clients to Always Supply Idempotency-Key  
**Why rejected**: Poor developer experience; naive users forget and cause accidental duplicates

## References
- AWS `ClientRequestToken` design
- Stripe API Idempotency documentation  
- Google Cloud `request_id` guidance
