---
description: Define Idempotency-Key and X-Request-Id semantics for Synapse APIs
---
# ADR-0015: Idempotency & Request-ID Semantics

| Status | Date | Deciders |
| ------ | ---- | -------- |
| ✅ Accepted | 2025-07-27 | @core-team |

## Context

Reliable client retries require two related but distinct tokens:

1. **Idempotency-Key** – identifies a *logical* state-changing operation so the server can deduplicate duplicates.
2. **Request-Id** – identifies a *single HTTP attempt* for tracing and log correlation.

Industry practice (AWS ClientToken, Stripe Idempotency-Key, Google `request_id`) follows this split.

## Decision

### Header Names
* REST: `Idempotency-Key`, `Request-Id` headers.
* MCP tools: optional arguments `idempotency_key`, `request_id`; CLI flags `--idempotency-key`, `--request-id`.

### SDK Behaviour
### Generation Responsibilities
* **Idempotency-Key**
  * **Desirable source**: the *caller* (LLM agent, SaaS front-end, etc.) passes a stable key when it decides a logical write should be idempotent across retries or across multiple hops.
  * **SDK fallback**: when the caller omits the header the Go SDK will generate a UUID-v4 once per logical operation and reuse it on automatic retries. This guarantees safety for naïve clients but encourages advanced callers to provide their own key.
* **Request-Id**
  * Always generated by the **Go SDK** for *every* HTTP attempt (each retry) unless the caller explicitly overrides it.  This value is **never** reused across retries—even when the Idempotency-Key is reused.
  * Echoed in server responses and logs for trace correlation.

### Server Behaviour
* Maintain `<method , canonical_path , Idempotency-Key>` key for 24 h.
* If a duplicate arrives with the same body → return stored 2xx/4xx result.
* If duplicate body differs → return `409 Conflict` with error `idempotency_mismatch`.
* Always echo both headers (`Idempotency-Key`, `Request-Id`).

### TTL & Storage
* Keys live for 24 h (configurable); cleanup via background sweep.
* Implementation suggestion: Redis or Spanner table with composite primary key.

## Consequences

+ **Safety**: SDK-managed keys give automatic at-most-once semantics.
+ **Observability**: Request-Id enables end-to-end trace correlation.
+ **Flexibility**: Advanced clients can override both headers for custom workflows.

## Alternatives Considered
| Option | Reason Rejected |
| ------ | --------------- |
| Combine both concepts into one token | Blurs dedup vs. tracing concerns; breaks attempt-level visibility |
| Force clients to always supply Idempotency-Key | Bad DX; naïve users forget and cause accidental duplicates |

## References
* AWS `ClientRequestToken` design
* Stripe API Idempotency docs
* GCP `request_id` guidance 