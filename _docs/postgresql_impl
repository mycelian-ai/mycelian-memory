
I reviewed the storage interface, adapters (Postgres, SQLite, Spanner), HTTP routing/handlers, outbox worker, and Postgres compose to assess parity and gaps.

### Feature parity vs Spanner (what Postgres already has)
- Users (Create/Get/GetByEmail/UpdateLastActive): Implemented similarly in Postgres.
- Vaults (Create/Get/List/GetByTitle/Delete): Implemented in Postgres.
- Memories (Create/Get/List/GetByTitle/Delete): Implemented in Postgres; default context snapshot on create (Postgres/SQLite do this; Spanner did not rely on default context by design, acceptable divergence).
- Entries
  - Create/Get/GetByID/List/UpdateSummary/UpdateTags/DeleteByID: Implemented in Postgres.
  - CorrectMemoryEntry: Implemented in Postgres, but with two issues vs Spanner:
    - Missing `vault_id` scoping in SELECT/UPDATE and missing `vault_id` column in INSERT, which will violate schema and/or select wrong row:
      ```640:678:server/internal/storage/postgres/adapter.go
      // WHERE missing vault_id filter; INSERT missing vault_id column
      ```
    - ExpirationTime: Spanner persists/returns `ExpirationTime`; Postgres schema has it, but Create/List/Get don’t write/scan it.
- Contexts (Create/GetLatest/DeleteByID): Implemented in Postgres.
- Health: Implemented.

- Cross-vault memory association
  - AddMemoryToVault/DeleteMemoryFromVault: Not implemented in Spanner; also currently unimplemented in Postgres and SQLite:
    ```824:832:server/internal/storage/postgres/adapter.go
    func (s *PostgresStorage) AddMemoryToVault(...) error { return ErrNotImplemented }
    func (s *PostgresStorage) DeleteMemoryFromVault(...) error { return ErrNotImplemented }
    ```

Net: Postgres is broadly at Spanner parity, with two notable gaps to fix for correctness:
- CorrectMemoryEntry must include `vault_id` in WHEREs and INSERT, and optionally persist/return `expiration_time`.
- Cross-vault Add/Delete not implemented (Spanner didn’t have them either).

### Gaps vs the newer SQLite “vault model”
- Vault API surface: Present in both Postgres and SQLite (Create/Get/List/GetByTitle/Delete).
- Title-based memory HTTP endpoints (vaultTitle/memoryTitle): Present (`server/internal/api/http/memory.go`).
- Cross-vault operations: SQLite also has Add/Delete stubs returning not implemented, so Postgres is not behind SQLite here; both need it.
- Outbox integration: Postgres has robust outbox and worker; SQLite uses local publishes only. This is fine (Postgres ahead here).
- Compose model bootstrap: Postgres stack handles embedder; SQLite stack has been removed.

### Additional transport gaps
- No HTTP endpoint to trigger AddMemoryToVault; router has no route for it:
  ```1:81:server/internal/api/router.go
  // No route for memory move/add-to-vault
  ```

### Compose (Postgres) gaps
- No model-bootstrap step that pulls the embedding model before outbox-worker starts:
  ```103:126:deployments/docker/docker-compose.postgres.yml
  # outbox-worker depends on ollama+weaviate health, but not on a model pull bootstrap
  ```

### Updated Task List (Definition of Done: make test-all passes)

**Schema & Storage**
- [x] Remove expiration_time column from memory_entries in server/internal/storage/postgres/schema.sql (hard delete only)
- [x] Implement AddMemoryToVault - single transaction move with vault validation and title uniqueness enforcement  
- [x] Implement DeleteMemoryFromVault - delegate to existing DeleteMemory hard delete
- [x] Fix CorrectMemoryEntry vault_id scoping - add vault_id to SELECT/UPDATE predicates and INSERT columns
- [x] Fix UpdateMemoryEntrySummary/UpdateMemoryEntryTags to require vault_id scoping in WHERE clauses
- [x] Fix GetMemoryEntryByID to validate vault_id scoping (query with vault_id or validate post-scan)

**HTTP & Router**
- [x] Add HTTP endpoint POST /api/users/{userId}/vaults/{targetVaultId}/memories/{memoryId}/attach

**Docker Compose (Postgres)**
- [x] Remove in-stack Ollama; point OLLAMA_URL to localhost and let provider auto-pull model on demand

**Documentation**
- [x] Update docs/server/adr/0014-postgresql-migration.md to remove expiration_time and document vault isolation

**Tests & QA**
- [x] Run make test-all and fix any failures to achieve DoD
- [x] Makefile: ensure test-all fails on e2e failures (removed '|| true', added set -euo pipefail)

**Key Constraints:**
- Hard delete only (no expiration_time)
- Strict vault_id isolation for all memory/entry/context operations  
- No cross-vault sharing allowed (move is ok, sharing is not)
- Empty database (0 users, no migration complexity)
- Search scoping remains unchanged (out of scope)

### Implementation Notes
- Moving a memory changes composite PK; ensure child updates complete in the same tx to avoid breaks. No FKs in current schema ease the update.
- MemoryID uniqueness across a user is practical (UUID) but not enforced; selecting source by `(user_id, memory_id)` is acceptable.
- Outbox not re-run on move: acceptable since aggregate IDs (entryId/contextId) don't change; vector store is user-scoped.
- Postgres correction bug will likely cause test failures (missing `vault_id` in correction queries/inserts). Fixing that early will smooth the test run.
- Compose bootstrap: using `curlimages/curl` to POST `/api/pull` is simpler than invoking the Ollama CLI in another container.